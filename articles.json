[{"intro":"<p>最近做大作业需要研究一下Node.js，需要了解node与mongoDB的链接，前后端的通信，后端的逻辑结构等，怎么快速上手呢？那就做个聊天室吧。</p>\n","content":"<p>最近做大作业需要研究一下Node.js，需要了解node与mongoDB的链接，前后端的通信，后端的逻辑结构等，怎么快速上手呢？那就做个聊天室吧。</p>\n<h2 id=\"安装nodejs和mongodb\">安装Node.JS和MongoDB</h2>\n<p>Node.js就不多说了，MongoDB可以看我上一篇<a href=\"http://www.xiao555.club/2016/04/30/win7%20%E5%AE%89%E8%A3%85MongoDB/\">博客</a></p>\n<h2 id=\"构建express项目\">构建Express项目</h2>\n<p>找一个合适的地方：</p>\n<pre><code class=\"language-bash\"><span class=\"hljs-attr\">mkdir</span> <span class=\"hljs-string\">chatroom</span>\n\n<span class=\"hljs-attr\">cd</span> <span class=\"hljs-string\">chatroom</span>\n\n<span class=\"hljs-attr\">npm</span> <span class=\"hljs-string\">install express</span>\n\n<span class=\"hljs-attr\">express</span> <span class=\"hljs-string\">-e  //-e 是用ejs作为模板引擎</span>\n\n<span class=\"hljs-attr\">npm</span> <span class=\"hljs-string\">install //安装依赖，目录在package.json中</span>\n</code></pre>\n<p>这样就创建好了，结构如下：</p>\n<pre><code class=\"language-bash\">-<span class=\"ruby\"> chatroom\n</span>\n    -<span class=\"ruby\"> bin\n</span>        -<span class=\"ruby\"> www           /<span class=\"hljs-regexp\">/配置端口启动文件\n</span></span>    -<span class=\"ruby\"><span class=\"hljs-regexp\"> node_modules        /</span><span class=\"hljs-regexp\">/下载的模块\n</span></span>        -<span class=\"ruby\"><span class=\"hljs-regexp\"> express\n</span></span>    -<span class=\"ruby\"><span class=\"hljs-regexp\"> public            /</span><span class=\"hljs-regexp\">/静态资源\n</span></span>        -<span class=\"ruby\"><span class=\"hljs-regexp\"> images\n</span></span>        -<span class=\"ruby\"><span class=\"hljs-regexp\"> javascripts\n</span></span>        -<span class=\"ruby\"><span class=\"hljs-regexp\"> stylesheets\n</span></span>    -<span class=\"ruby\"><span class=\"hljs-regexp\"> routes            /</span><span class=\"hljs-regexp\">/后端逻辑、路由\n</span></span>        -<span class=\"ruby\"><span class=\"hljs-regexp\"> index.js\n</span></span>        -<span class=\"ruby\"><span class=\"hljs-regexp\"> users.js\n</span></span>    -<span class=\"ruby\"><span class=\"hljs-regexp\"> views                /</span><span class=\"hljs-regexp\">/视图\n</span></span>        -<span class=\"ruby\"><span class=\"hljs-regexp\"> error.ejs\n</span></span>        -<span class=\"ruby\"><span class=\"hljs-regexp\"> index.ejs\n</span></span>    -<span class=\"ruby\"><span class=\"hljs-regexp\"> app.js             /</span><span class=\"hljs-regexp\">/入口文件，相当于main();\n</span></span>    -<span class=\"ruby\"><span class=\"hljs-regexp\"> package.json         /</span><span class=\"hljs-regexp\">/配置信息</span></span></code></pre>\n<p>我按照个人习惯做一些调整</p>\n<pre><code>-<span class=\"ruby\"> chatroom\n</span>\n    -<span class=\"ruby\"> node_modules        /<span class=\"hljs-regexp\">/下载的模块\n</span></span>        -<span class=\"ruby\"><span class=\"hljs-regexp\"> express\n</span></span>    -<span class=\"ruby\"><span class=\"hljs-regexp\"> public            /</span><span class=\"hljs-regexp\">/静态资源\n</span></span>        -<span class=\"ruby\"><span class=\"hljs-regexp\"> img\n</span></span>        -<span class=\"ruby\"><span class=\"hljs-regexp\"> js\n</span></span>        -<span class=\"ruby\"><span class=\"hljs-regexp\"> css\n</span></span>    -<span class=\"ruby\"><span class=\"hljs-regexp\"> routes            /</span><span class=\"hljs-regexp\">/后端逻辑、路由\n</span></span>        -<span class=\"ruby\"><span class=\"hljs-regexp\"> index.js\n</span></span>        -<span class=\"ruby\"><span class=\"hljs-regexp\"> users.js\n</span></span>    -<span class=\"ruby\"><span class=\"hljs-regexp\"> views                /</span><span class=\"hljs-regexp\">/视图\n</span></span>        -<span class=\"ruby\"><span class=\"hljs-regexp\"> error.ejs\n</span></span>        -<span class=\"ruby\"><span class=\"hljs-regexp\"> index.ejs\n</span></span>    -<span class=\"ruby\"><span class=\"hljs-regexp\"> app.js             /</span><span class=\"hljs-regexp\">/入口文件，相当于main();\n</span></span>    -<span class=\"ruby\"><span class=\"hljs-regexp\"> package.json         /</span><span class=\"hljs-regexp\">/配置信息</span></span></code></pre><p>我把public目录下目录改一下名称，www文件删了，用app.js作为启动文件，就需要修改一下app.js：</p>\n<pre><code class=\"language-javascript\">var <span class=\"hljs-keyword\">debug</span> = require(<span class=\"hljs-string\">'debug'</span>)(<span class=\"hljs-string\">'chat'</span>);\n//var users = require(<span class=\"hljs-string\">'./routes/users'</span>);    //单页面不需要这个\n\napp.<span class=\"hljs-keyword\">set</span>(<span class=\"hljs-string\">'port'</span>, process.env.PORT || <span class=\"hljs-number\">3000</span>);\n\nvar <span class=\"hljs-keyword\">server</span> = app.<span class=\"hljs-keyword\">listen</span>(app.<span class=\"hljs-keyword\">get</span>(<span class=\"hljs-string\">'port'</span>), <span class=\"hljs-keyword\">function</span>(){\n  <span class=\"hljs-keyword\">debug</span>(<span class=\"hljs-string\">'Express server listening on port '</span> + <span class=\"hljs-keyword\">server</span>.address().port);\n})\n\n//app.use(<span class=\"hljs-string\">'/users'</span>, users);</code></pre>\n<p>增加，注释这些后，运行 <code>DEBUG=chatroom &amp; node app.js</code> 或 <code>node app.js</code> ,然后浏览器打开<a href=\"127.0.0.1:3000\">127.0.0.1:3000</a>,如下图所示，就说明配置好了</p>\n<p><img src=\"http://ww3.sinaimg.cn/mw1024/005NJVkbjw1f3fsnv448uj311y0kg0vk.jpg\" alt=\"\"></p>\n<h2 id=\"实现前端页面\">实现前端页面</h2>\n<p>这个没什么好说的，修改views目录下的index.ejs文件，效果如下：</p>\n<p><img src=\"http://ww3.sinaimg.cn/mw1024/005NJVkbjw1f3ftv2386qj311y0kg0wl.jpg\" alt=\"\"></p>\n<h2 id=\"数据库设计\">数据库设计</h2>\n<p>注意使用数据库前一定要先开启mongodb服务！</p>\n<p>安装 mongodb 和 mongoose 模块：</p>\n<pre><code class=\"language-bash\">npm <span class=\"hljs-keyword\">install</span> mongodb mongoose</code></pre>\n<p>在主目录下新建chat_server.js :</p>\n<pre><code class=\"language-javascript\"><span class=\"hljs-keyword\">var</span> mongoose = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">'mongoose'</span>);\n\n<span class=\"hljs-comment\">//连接数据库</span>\n<span class=\"hljs-keyword\">var</span> db = mongoose.createConnection(<span class=\"hljs-string\">'localhost'</span>,<span class=\"hljs-string\">'chatroom'</span>);\ndb.on(<span class=\"hljs-string\">'error'</span>,<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">err</span>) </span>{\n    <span class=\"hljs-built_in\">console</span>.error(err);\n});\n<span class=\"hljs-keyword\">var</span> Schema = mongoose.Schema;\n\n<span class=\"hljs-comment\">//聊天记录表</span>\n<span class=\"hljs-keyword\">var</span> ChatSchema = <span class=\"hljs-keyword\">new</span> Schema({\n    <span class=\"hljs-attr\">nickname</span>: <span class=\"hljs-built_in\">String</span>,\n    <span class=\"hljs-attr\">time</span>: <span class=\"hljs-built_in\">String</span>,\n    <span class=\"hljs-attr\">content</span>: <span class=\"hljs-built_in\">String</span>\n});\n<span class=\"hljs-keyword\">var</span> ChatModel = db.model(<span class=\"hljs-string\">'chats'</span>,ChatSchema);\n\n\n<span class=\"hljs-comment\">// 这里的listen函数在 app.js 文件中被调用</span>\nexports.listen = <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">_server</span>)</span>{\n    <span class=\"hljs-keyword\">return</span> io.listen(_server);\n}</code></pre>\n<p>在app.js中增加：</p>\n<pre><code class=\"language-javascript\"><span class=\"hljs-selector-tag\">require</span>(<span class=\"hljs-string\">'./chat\\_server'</span>)<span class=\"hljs-selector-class\">.listen</span>(server);</code></pre>\n<h2 id=\"前后端通信socketio\">前后端通信Socket.io</h2>\n<p>借用这篇<a href=\"http://my.oschina.net/voler/blog/626226?fromerr=UumMewCx\">博客</a>里讲的介绍一下socket.io：</p>\n<p>首先先简单讲解下Socket.io的原理. 操作系统有一个非常伟大的设计就是轮询机制,而Node.js中的callback机制正是基于此机制:</p>\n<p><img src=\"http://static.oschina.net/uploads/space/2016/0301/084929_dx2L_1017135.png\" alt=\"\"></p>\n<p>JS的异步编程就是这么来的.但是对于类似聊天这种应用,使用轮询机制明显不合理.轮询机制在于你触发了一个事件后异步处理,但这里异步本身就是硬伤,毕竟聊天要实时的.</p>\n<p>而Node.js中有另外一种伟大的模型: 观察者模式. 即我就一直监听,监听到的某个事件后,执行相应的处理函数.</p>\n<p><img src=\"https://xiao555.netlify.com/\" alt=\"\"></p>\n<h3 id=\"举个栗子\">举个栗子</h3>\n<p>在chat_server.js中添加：</p>\n<pre><code class=\"language-javascript\">var io = require('socket.io')<span class=\"hljs-literal\">()</span>;\nvar xssEscape = require('xss-escape');\n\nvar nickname_list = <span class=\"hljs-literal\">[]</span>;\n\n<span class=\"hljs-comment\">// 检查是昵称是否已经存在</span>\n<span class=\"hljs-keyword\">function</span> <span class=\"hljs-constructor\">HasNickname(<span class=\"hljs-params\">_nickname</span>)</span>{\n    for(var i=<span class=\"hljs-number\">0</span>; i&lt;nickname_list.length; i++){\n        <span class=\"hljs-keyword\">if</span>(nickname_list<span class=\"hljs-literal\">[<span class=\"hljs-identifier\">i</span>]</span><span class=\"hljs-operator\"> == </span>_nickname){\n            return <span class=\"hljs-literal\">true</span>;\n        }\n    }\n};\n\n<span class=\"hljs-comment\">// 删除昵称</span>\n<span class=\"hljs-keyword\">function</span> <span class=\"hljs-constructor\">RemoveNickname(<span class=\"hljs-params\">_nickname</span>)</span>{\n    for(var i=<span class=\"hljs-number\">0</span>; i&lt; nickname_list.length; i++){\n        <span class=\"hljs-keyword\">if</span>(nickname_list<span class=\"hljs-literal\">[<span class=\"hljs-identifier\">i</span>]</span><span class=\"hljs-operator\"> == </span>_nickname){\n            nickname_list.splice(i, <span class=\"hljs-number\">1</span>);\n        }\n    }\n}\n\nio.on('connection', <span class=\"hljs-keyword\">function</span>(_socket){\n    console.log(<span class=\"hljs-module-access\"><span class=\"hljs-module\"><span class=\"hljs-identifier\">_socket</span>.</span></span>id + ':connection');\n\n    <span class=\"hljs-comment\">// 向当前用户发送命令和消息</span>\n    <span class=\"hljs-module-access\"><span class=\"hljs-module\"><span class=\"hljs-identifier\">_socket</span>.</span></span>emit('user_list', nickname_list);\n    <span class=\"hljs-module-access\"><span class=\"hljs-module\"><span class=\"hljs-identifier\">_socket</span>.</span></span>emit('need_nickname');\n    <span class=\"hljs-module-access\"><span class=\"hljs-module\"><span class=\"hljs-identifier\">_socket</span>.</span></span>emit('server_message<span class=\"hljs-character\">','</span>欢迎来到聊天室 :)');\n\n    <span class=\"hljs-comment\">// 监听当前用户的请求和数据</span>\n\n    <span class=\"hljs-comment\">// 离开</span>\n    <span class=\"hljs-module-access\"><span class=\"hljs-module\"><span class=\"hljs-identifier\">_socket</span>.</span></span>on('disconnect', <span class=\"hljs-keyword\">function</span><span class=\"hljs-literal\">()</span>{\n        console.log(<span class=\"hljs-module-access\"><span class=\"hljs-module\"><span class=\"hljs-identifier\">_socket</span>.</span></span>id + ':disconnect');\n        <span class=\"hljs-keyword\">if</span>(<span class=\"hljs-module-access\"><span class=\"hljs-module\"><span class=\"hljs-identifier\">_socket</span>.</span></span>nickname != null<span class=\"hljs-operator\"> &amp;&amp; </span><span class=\"hljs-module-access\"><span class=\"hljs-module\"><span class=\"hljs-identifier\">_socket</span>.</span></span>nickname != <span class=\"hljs-string\">\"\"</span>){\n            <span class=\"hljs-comment\">// 广播 用户退出</span>\n            <span class=\"hljs-module-access\"><span class=\"hljs-module\"><span class=\"hljs-identifier\">_socket</span>.</span></span>broadcast.emit('user_quit', <span class=\"hljs-module-access\"><span class=\"hljs-module\"><span class=\"hljs-identifier\">_socket</span>.</span></span>nickname);\n            <span class=\"hljs-constructor\">RemoveNickname(<span class=\"hljs-params\">_socket</span>.<span class=\"hljs-params\">nickname</span>)</span>;\n        }\n    });\n\n    <span class=\"hljs-comment\">// 添加 和 修改 昵称</span>\n    <span class=\"hljs-module-access\"><span class=\"hljs-module\"><span class=\"hljs-identifier\">_socket</span>.</span></span>on('change_nickname', <span class=\"hljs-keyword\">function</span>(_nickname, clr){\n        console.log(<span class=\"hljs-module-access\"><span class=\"hljs-module\"><span class=\"hljs-identifier\">_socket</span>.</span></span>id + ': change<span class=\"hljs-constructor\">_nickname('+<span class=\"hljs-params\">_nickname</span>+')</span>');\n\n        _nickname = xss<span class=\"hljs-constructor\">Escape(<span class=\"hljs-params\">_nickname</span>.<span class=\"hljs-params\">trim</span>()</span>);\n\n        <span class=\"hljs-comment\">// 半角替换为tt，模拟为全角字符判断长度</span>\n        var name_len = <span class=\"hljs-module-access\"><span class=\"hljs-module\"><span class=\"hljs-identifier\">_nickname</span>.</span></span>replace(/<span class=\"hljs-literal\">[^\\<span class=\"hljs-identifier\">u0000</span>-\\<span class=\"hljs-identifier\">u00ff</span>]</span>/g, <span class=\"hljs-string\">\"tt\"</span>).length;\n\n        <span class=\"hljs-comment\">// 字符长度必须在4到16个字符之间</span>\n        <span class=\"hljs-keyword\">if</span>(name_len &lt; <span class=\"hljs-number\">4</span><span class=\"hljs-operator\"> || </span>name_len &gt; <span class=\"hljs-number\">16</span>){\n            return <span class=\"hljs-module-access\"><span class=\"hljs-module\"><span class=\"hljs-identifier\">_socket</span>.</span></span>emit('change_nickname_error', '请填写正确的用户昵称，应在<span class=\"hljs-number\">4</span>到<span class=\"hljs-number\">16</span>个字符之间。')\n        }\n\n        <span class=\"hljs-comment\">// 昵称重复</span>\n        <span class=\"hljs-keyword\">if</span>(<span class=\"hljs-module-access\"><span class=\"hljs-module\"><span class=\"hljs-identifier\">_socket</span>.</span></span>nickname<span class=\"hljs-operator\"> == </span>_nickname){\n            return <span class=\"hljs-module-access\"><span class=\"hljs-module\"><span class=\"hljs-identifier\">_socket</span>.</span></span>emit('change_nickname_error', '你本来就叫这个名字。')\n        }\n\n        <span class=\"hljs-comment\">// 昵称已经被占用</span>\n        <span class=\"hljs-keyword\">if</span>(<span class=\"hljs-constructor\">HasNickname(<span class=\"hljs-params\">_nickname</span>)</span>){\n            return <span class=\"hljs-module-access\"><span class=\"hljs-module\"><span class=\"hljs-identifier\">_socket</span>.</span></span>emit('change_nickname_error', '此昵称已经被占用。')\n        }\n\n        var old_name = '';\n        <span class=\"hljs-keyword\">if</span>(<span class=\"hljs-module-access\"><span class=\"hljs-module\"><span class=\"hljs-identifier\">_socket</span>.</span></span>nickname != ''<span class=\"hljs-operator\"> &amp;&amp; </span><span class=\"hljs-module-access\"><span class=\"hljs-module\"><span class=\"hljs-identifier\">_socket</span>.</span></span>nickname != null){\n            old_name = <span class=\"hljs-module-access\"><span class=\"hljs-module\"><span class=\"hljs-identifier\">_socket</span>.</span></span>nickname;\n            <span class=\"hljs-constructor\">RemoveNickname(<span class=\"hljs-params\">old_name</span>)</span>;\n        }\n\n        nickname_list.push(_nickname);\n        <span class=\"hljs-module-access\"><span class=\"hljs-module\"><span class=\"hljs-identifier\">_socket</span>.</span></span>nickname = _nickname;\n        <span class=\"hljs-module-access\"><span class=\"hljs-module\"><span class=\"hljs-identifier\">_socket</span>.</span></span>color = clr;\n\n        console.log(nickname_list);\n\n        <span class=\"hljs-module-access\"><span class=\"hljs-module\"><span class=\"hljs-identifier\">_socket</span>.</span></span>emit('change_nickname_done', old_name, _nickname, clr);\n\n        <span class=\"hljs-keyword\">if</span>(old_name<span class=\"hljs-operator\"> == </span>''){\n            <span class=\"hljs-comment\">// 广播 用户加入</span>\n            return <span class=\"hljs-module-access\"><span class=\"hljs-module\"><span class=\"hljs-identifier\">_socket</span>.</span></span>broadcast.emit('user_join', _nickname);\n        }<span class=\"hljs-keyword\">else</span>{\n            <span class=\"hljs-comment\">// 广播 用户改名</span>\n            return <span class=\"hljs-module-access\"><span class=\"hljs-module\"><span class=\"hljs-identifier\">_socket</span>.</span></span>broadcast.emit('user_change_nickname', old_name, _nickname);\n        }\n    });\n\n    <span class=\"hljs-comment\">// 说话</span>\n    <span class=\"hljs-module-access\"><span class=\"hljs-module\"><span class=\"hljs-identifier\">_socket</span>.</span></span>on('say', <span class=\"hljs-keyword\">function</span>(_time, _content){\n        <span class=\"hljs-keyword\">if</span>(''<span class=\"hljs-operator\"> == </span><span class=\"hljs-module-access\"><span class=\"hljs-module\"><span class=\"hljs-identifier\">_socket</span>.</span></span>nickname<span class=\"hljs-operator\"> || </span>null<span class=\"hljs-operator\"> == </span><span class=\"hljs-module-access\"><span class=\"hljs-module\"><span class=\"hljs-identifier\">_socket</span>.</span></span>nickname){\n            return <span class=\"hljs-module-access\"><span class=\"hljs-module\"><span class=\"hljs-identifier\">_socket</span>.</span></span>emit('need_nickname');\n        }\n\n        _content = <span class=\"hljs-module-access\"><span class=\"hljs-module\"><span class=\"hljs-identifier\">_content</span>.</span></span>trim<span class=\"hljs-literal\">()</span>;\n        var chatinfo = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-constructor\">ChatModel()</span>;\n        chatinfo.nickname = <span class=\"hljs-module-access\"><span class=\"hljs-module\"><span class=\"hljs-identifier\">_socket</span>.</span></span>nickname;\n        chatinfo.time = _time;\n        chatinfo.content = _content;\n        chatinfo.save(<span class=\"hljs-keyword\">function</span>(err) {\n            <span class=\"hljs-keyword\">if</span> (err) throw err;\n        });\n        <span class=\"hljs-module-access\"><span class=\"hljs-module\"><span class=\"hljs-identifier\">ChatModel</span>.</span></span>find({nickname: <span class=\"hljs-module-access\"><span class=\"hljs-module\"><span class=\"hljs-identifier\">_socket</span>.</span></span>nickname},<span class=\"hljs-keyword\">function</span>(err,data) {\n            <span class=\"hljs-keyword\">if</span> (err) {\n             console.log('存储失败' + err);\n             return;\n             } <span class=\"hljs-keyword\">else</span> {\n             console.log('存储成功：' + data);\n             }\n        });\n        console.log(<span class=\"hljs-module-access\"><span class=\"hljs-module\"><span class=\"hljs-identifier\">_socket</span>.</span></span>nickname + ': say('+_content+<span class=\"hljs-character\">')'</span>);\n        <span class=\"hljs-comment\">// 广播 用户新消息</span>\n        <span class=\"hljs-module-access\"><span class=\"hljs-module\"><span class=\"hljs-identifier\">_socket</span>.</span></span>broadcast.emit('user_say', <span class=\"hljs-module-access\"><span class=\"hljs-module\"><span class=\"hljs-identifier\">_socket</span>.</span></span>nickname, xss<span class=\"hljs-constructor\">Escape(<span class=\"hljs-params\">_content</span>)</span>, <span class=\"hljs-module-access\"><span class=\"hljs-module\"><span class=\"hljs-identifier\">_socket</span>.</span></span>color);\n        return <span class=\"hljs-module-access\"><span class=\"hljs-module\"><span class=\"hljs-identifier\">_socket</span>.</span></span>emit('say_done', <span class=\"hljs-module-access\"><span class=\"hljs-module\"><span class=\"hljs-identifier\">_socket</span>.</span></span>nickname, xss<span class=\"hljs-constructor\">Escape(<span class=\"hljs-params\">_content</span>)</span>, <span class=\"hljs-module-access\"><span class=\"hljs-module\"><span class=\"hljs-identifier\">_socket</span>.</span></span>color);\n    });\n\n    <span class=\"hljs-comment\">//显示历史记录</span>\n    <span class=\"hljs-module-access\"><span class=\"hljs-module\"><span class=\"hljs-identifier\">_socket</span>.</span></span>on('show_history',<span class=\"hljs-keyword\">function</span>(clr){\n        console.log('ok');\n        <span class=\"hljs-module-access\"><span class=\"hljs-module\"><span class=\"hljs-identifier\">ChatModel</span>.</span></span>find({},<span class=\"hljs-keyword\">function</span>(err,data) {\n            <span class=\"hljs-keyword\">if</span> (err) {\n             console.error(err);\n             return;\n             } <span class=\"hljs-keyword\">else</span> {\n                 console.log('data = ' + data);\n                 console.log(data<span class=\"hljs-literal\">[<span class=\"hljs-number\">0</span>]</span>.nickname);\n                 for(var i = <span class=\"hljs-number\">0</span>;i &lt; data.length;i++){\n                    console.log(data<span class=\"hljs-literal\">[<span class=\"hljs-identifier\">i</span>]</span>.nickname, data<span class=\"hljs-literal\">[<span class=\"hljs-identifier\">i</span>]</span>.time, xss<span class=\"hljs-constructor\">Escape(<span class=\"hljs-params\">data</span>[<span class=\"hljs-params\">i</span>].<span class=\"hljs-params\">content</span>)</span>, clr);\n                    <span class=\"hljs-module-access\"><span class=\"hljs-module\"><span class=\"hljs-identifier\">_socket</span>.</span></span>emit('return_history', data<span class=\"hljs-literal\">[<span class=\"hljs-identifier\">i</span>]</span>.nickname, data<span class=\"hljs-literal\">[<span class=\"hljs-identifier\">i</span>]</span>.time, xss<span class=\"hljs-constructor\">Escape(<span class=\"hljs-params\">data</span>[<span class=\"hljs-params\">i</span>].<span class=\"hljs-params\">content</span>)</span>, clr);\n                }\n             }\n        });\n    });\n})</code></pre>\n<p>这是后端的响应机制，前端逻辑在public目录下js中的index.js中,这里就简单举个例子，显示历史消息：</p>\n<pre><code class=\"language-javascript\"><span class=\"hljs-keyword\">var</span> chat_Utils,     <span class=\"hljs-comment\">//聊天室 工具类</span>\n    chat_UI,         <span class=\"hljs-comment\">//聊天室 界面逻辑</span>\n    chat_Socket;     <span class=\"hljs-comment\">//聊天室 数据逻辑</span>\n\n<span class=\"hljs-comment\">// 与后台服务器建立websocket连接</span>\n<span class=\"hljs-keyword\">var</span> chat_server = <span class=\"hljs-string\">\"http://\"</span> + location.hostname + <span class=\"hljs-string\">':3000'</span>;\n<span class=\"hljs-keyword\">var</span> socket = io.connect(chat_server);\n\n\nchat_UI = {\n    <span class=\"hljs-attr\">init</span>: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\"></span>)</span>{\n        <span class=\"hljs-keyword\">this</span>.historyShow();        <span class=\"hljs-comment\">//点击显示历史消息事件</span>\n    },\n    <span class=\"hljs-attr\">historyShow</span>:<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\"></span>)</span>{\n            <span class=\"hljs-keyword\">var</span> self = <span class=\"hljs-keyword\">this</span>;\n            $(<span class=\"hljs-string\">\"#showHistory\"</span>).on(<span class=\"hljs-string\">'click'</span>,<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\"></span>) </span>{\n                <span class=\"hljs-keyword\">if</span>($(<span class=\"hljs-string\">'#history-modal'</span>).css(<span class=\"hljs-string\">'display'</span>) == <span class=\"hljs-string\">'none'</span>) {\n                    $(<span class=\"hljs-string\">'.history-list-body'</span>).empty();\n                }\n                $(<span class=\"hljs-string\">\"#history-modal\"</span>).modal(<span class=\"hljs-string\">'show'</span>);\n                chat_Socket.showHistory(chat_Utils.getUserColor());\n            })\n    },\n    <span class=\"hljs-attr\">chatBodyToBottom</span>: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\"></span>)</span>{\n        <span class=\"hljs-keyword\">var</span> chat_body = $(<span class=\"hljs-string\">'.chat-body'</span>);\n        <span class=\"hljs-keyword\">var</span> height = chat_body.prop(<span class=\"hljs-string\">'scrollHeight'</span>);\n        chat_body.prop(<span class=\"hljs-string\">'scrollTop'</span>, height);\n    },\n    <span class=\"hljs-attr\">addHistoryMessage</span>: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">_time, _content, _name, clr</span>)</span>{\n        <span class=\"hljs-keyword\">var</span> history_list = $(<span class=\"hljs-string\">'.history-list-body'</span>);\n        _content = QxEmotion.Parse(_content);\n        <span class=\"hljs-keyword\">var</span> msgAlignCls = _name ==$(<span class=\"hljs-string\">'#my-nickname'</span>).text() ? <span class=\"hljs-string\">'msg-right'</span>:<span class=\"hljs-string\">'msg-left'</span>;\n        history_list.append(\n            <span class=\"hljs-string\">'&lt;div class=\"msg-item clearfix '</span>+msgAlignCls+<span class=\"hljs-string\">'\"&gt;\\\n                    &lt;div class=\"msg-avatar\" style=\"background-color:'</span>+clr+<span class=\"hljs-string\">';\"&gt;&lt;i class=\"glyphicon glyphicon-user\"&gt;&lt;/i&gt;&lt;/div&gt;\\\n                    &lt;div class=\"msg-con-box\" style=\"background-color:'</span>+clr+<span class=\"hljs-string\">';\"&gt;\\\n                        &lt;p class=\"con\"&gt;'</span>+_content+<span class=\"hljs-string\">'&lt;/p&gt;\\\n                        &lt;time class=\"time\"&gt;'</span>+_time+<span class=\"hljs-string\">'&lt;/time&gt;\\\n                    &lt;/div&gt;\\\n                &lt;/div&gt;'</span>\n            );\n        <span class=\"hljs-keyword\">this</span>.chatBodyToBottom();\n\n    },\n};\n\nchat_Socket = {\n    <span class=\"hljs-attr\">init</span>:<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\"></span>)</span>{\n        <span class=\"hljs-keyword\">this</span>.chatHistoryEv();<span class=\"hljs-comment\">//监听后端 获取历史消息</span>\n    },\n    <span class=\"hljs-attr\">showHistory</span>:<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">clr</span>)</span>{\n        socket.emit(<span class=\"hljs-string\">'show_history'</span>,clr);\n    },\n    <span class=\"hljs-attr\">chatHistoryEv</span>:<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\"></span>)</span>{\n        socket.on(<span class=\"hljs-string\">'return_history'</span>,<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">_nickname, _time, _content, clr</span>) </span>{\n            <span class=\"hljs-built_in\">console</span>.log(_nickname, _time, _content, clr);\n            chat_UI.addHistoryMessage(_time, _content, _nickname, clr);\n        });\n    },\n}\n\nchat_UI.init();\nchat_Socket.init();</code></pre>\n<p>我们过一下思路，首先当用户点击显示历史消息时，调用chat_UI.historyShow函数，先清空一下历史记录列表，然后显示历史记录弹窗，调用chat_Socket.showHistory函数：</p>\n<pre><code class=\"language-javascript\">historyShow:<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\"></span>)</span>{\n            <span class=\"hljs-keyword\">var</span> self = <span class=\"hljs-keyword\">this</span>;\n            $(<span class=\"hljs-string\">\"#showHistory\"</span>).on(<span class=\"hljs-string\">'click'</span>,<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\"></span>) </span>{\n                <span class=\"hljs-keyword\">if</span>($(<span class=\"hljs-string\">'#history-modal'</span>).css(<span class=\"hljs-string\">'display'</span>) == <span class=\"hljs-string\">'none'</span>) {\n                    $(<span class=\"hljs-string\">'.history-list-body'</span>).empty();\n                }\n                $(<span class=\"hljs-string\">\"#history-modal\"</span>).modal(<span class=\"hljs-string\">'show'</span>);\n                chat_Socket.showHistory(chat_Utils.getUserColor());\n            })\n    },</code></pre>\n<p>chat_Socket.showHistory这个函数调用socket.emit发射show_history事件：</p>\n<pre><code class=\"language-javascript\">showHistory:<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span><span class=\"hljs-params\">(clr)</span></span>{\n        socket.emit(<span class=\"hljs-string\">'show_history'</span>,clr);\n    },</code></pre>\n<p>后端chat_server.js 中用socket.on(‘show_history’)捕获了这一事件,从数据库中获取数据发送return_history事件到前端：</p>\n<pre><code class=\"language-javascript\"><span class=\"hljs-comment\">//显示历史记录</span>\n    _socket.on(<span class=\"hljs-string\">'show_history'</span>,<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">clr</span>)</span>{\n        <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">'ok'</span>);\n        ChatModel.find({},<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">err,data</span>) </span>{\n            <span class=\"hljs-keyword\">if</span> (err) {\n             <span class=\"hljs-built_in\">console</span>.error(err);\n             <span class=\"hljs-keyword\">return</span>;\n             } <span class=\"hljs-keyword\">else</span> {\n                 <span class=\"hljs-keyword\">for</span>(<span class=\"hljs-keyword\">var</span> i = <span class=\"hljs-number\">0</span>;i &lt; data.length;i++){\n                    _socket.emit(<span class=\"hljs-string\">'return_history'</span>, data[i].nickname, data[i].time, xssEscape(data[i].content), clr);\n                }\n             }\n        });\n    });</code></pre>\n<p>前端index.js 中 chat_Socket.chatHistoryEv()函数捕获return_history事件，调用chat_UI.addHistoryMessage添加到历史记录列表中：</p>\n<pre><code class=\"language-javascript\">chatHistoryEv:function(){\n        socket.on(<span class=\"hljs-string\">'return_history'</span>,function(<span class=\"hljs-variable\">_nickname</span>, <span class=\"hljs-variable\">_time</span>, <span class=\"hljs-variable\">_content</span>, clr) {\n            console.<span class=\"hljs-built_in\">log</span>(<span class=\"hljs-variable\">_nickname</span>, <span class=\"hljs-variable\">_time</span>, <span class=\"hljs-variable\">_content</span>, clr);\n            chat_UI.addHistoryMessage(<span class=\"hljs-variable\">_time</span>, <span class=\"hljs-variable\">_content</span>, <span class=\"hljs-variable\">_nickname</span>, clr);\n        });\n    },</code></pre>\n<p>整个显示历史记录的过程就结束了。</p>\n<h2 id=\"数据库的操作\">数据库的操作</h2>\n<p>前面我们已经设计好了数据库：</p>\n<pre><code class=\"language-javascript\"><span class=\"hljs-keyword\">var</span> mongoose = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">'mongoose'</span>);\n\n<span class=\"hljs-comment\">//连接数据库</span>\n<span class=\"hljs-keyword\">var</span> db = mongoose.createConnection(<span class=\"hljs-string\">'localhost'</span>,<span class=\"hljs-string\">'chatroom'</span>);\ndb.on(<span class=\"hljs-string\">'error'</span>,<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">err</span>) </span>{\n    <span class=\"hljs-built_in\">console</span>.error(err);\n});\n<span class=\"hljs-keyword\">var</span> Schema = mongoose.Schema;\n\n<span class=\"hljs-comment\">//聊天记录表</span>\n<span class=\"hljs-keyword\">var</span> ChatSchema = <span class=\"hljs-keyword\">new</span> Schema({\n    <span class=\"hljs-attr\">nickname</span>: <span class=\"hljs-built_in\">String</span>,\n    <span class=\"hljs-attr\">time</span>: <span class=\"hljs-built_in\">String</span>,\n    <span class=\"hljs-attr\">content</span>: <span class=\"hljs-built_in\">String</span>\n});\n<span class=\"hljs-keyword\">var</span> ChatModel = db.model(<span class=\"hljs-string\">'chats'</span>,ChatSchema);</code></pre>\n<p>数据库的设计包括Schema 模式(数据记录的格式)、Model 编译模型、Documents 文档实例化。上面的代码中我们连接了chatroom数据库，设计了ChatSchema模式，编译了ChatModel 模型，编译好模型后我们创建一条新的记录只需要new一下就行。</p>\n<h3 id=\"保存新数据\">保存新数据</h3>\n<pre><code class=\"language-javascript\">var chatinfo = new ChatModel()<span class=\"hljs-comment\">;</span>\n        chatinfo.nickname = _socket.nickname<span class=\"hljs-comment\">;</span>\n        chatinfo.time = _time<span class=\"hljs-comment\">;</span>\n        chatinfo.content = _content<span class=\"hljs-comment\">;</span>\n        chatinfo.save(function(err) {\n            if (err) throw err<span class=\"hljs-comment\">;</span>\n        })<span class=\"hljs-comment\">;</span></code></pre>\n<h3 id=\"查询数据\">查询数据</h3>\n<pre><code class=\"language-javascript\">ChatModel.<span class=\"hljs-built_in\">find</span>({nickname: _socket.nickname},<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span><span class=\"hljs-params\">(err,data)</span></span> {\n            <span class=\"hljs-keyword\">if</span> (err) {\n             console.<span class=\"hljs-built_in\">log</span>(<span class=\"hljs-string\">'存储失败'</span> + err);\n             <span class=\"hljs-keyword\">return</span>;\n             } <span class=\"hljs-keyword\">else</span> {\n             console.<span class=\"hljs-built_in\">log</span>(<span class=\"hljs-string\">'存储成功：'</span> + data);\n             }\n        });</code></pre>\n<p>除了.find() 查找所有符合的数据，还有.findOne() 查找一条数据，第二个参数中的data就是返回的数据。</p>\n<p>至此基本的逻辑和操作我们都了解了，接下来就是Codeing的时间了！</p>\n<h2 id=\"部署到vps上\">部署到vps上</h2>\n<p>将项目搬到/var/www/chatroom/下，这里我是用git传到github上然后git clone过去的。</p>\n<h3 id=\"安装mongodb服务\">安装mongodb服务</h3>\n<p>由于我的vps是32位的CentOS，一直很头痛这个32位还有CentOS,但是里面又配置了一些梯子，不想折腾就没换，连Docker也用不了。。。那怎么安装mongodb呢？</p>\n<p>参考：<a href=\"http://www.thinksaas.cn/topics/0/424/424694.html\">CentOS 6.5系统中使用yum安装MongoDB 2.6 教程</a></p>\n<h4 id=\"创建mongodbrepo文件\">创建mongodb.repo文件</h4>\n<p>在/etc/yum.repos.d/目录下创建文件mongodb.repo，它包含MongoDB仓库的配置信息，内容如下：</p>\n<pre><code><span class=\"hljs-section\">[mongodb]</span>\n<span class=\"hljs-attr\">name</span>=MongoDB Repository\n<span class=\"hljs-attr\">baseurl</span>=http://downloads-distro.mongodb.org/repo/redhat/os/i686/\n<span class=\"hljs-attr\">gpgcheck</span>=<span class=\"hljs-number\">0</span>\n<span class=\"hljs-attr\">enabled</span>=<span class=\"hljs-number\">1</span></code></pre><h4 id=\"执行安装命令\">执行安装命令</h4>\n<pre><code>sudo yum <span class=\"hljs-keyword\">install</span> mongodb-org</code></pre><h4 id=\"启动mongodb\">启动MongoDB</h4>\n<pre><code>sudo<span class=\"hljs-built_in\"> service </span>mongod start</code></pre><h3 id=\"运行appjs\">运行app.js</h3>\n<p>切换到项目目录，为了能一直自行程序，我们用forever模块：</p>\n<pre><code>sudo npm -g install <span class=\"hljs-keyword\">forever</span> <span class=\"hljs-comment\"> //安装</span>\n\n<span class=\"hljs-keyword\">forever</span> <span class=\"hljs-built_in\">start</span> app.js         <span class=\"hljs-comment\"> //开启进程</span>\n\n<span class=\"hljs-keyword\">forever</span> list                 <span class=\"hljs-comment\"> //查看所有进程</span>\n\n<span class=\"hljs-keyword\">forever</span> stopall                <span class=\"hljs-comment\"> //关闭所有进程</span>\n</code></pre><p>现在在你服务器的3000端口我们的聊天室已经完美运行了！</p>\n","title":"用Express + Socket.io + MongoDB实现简易聊天室","tags":["用Express","Socket.io","MongoDB"],"slug":"simple-chat-room-with-express-%2B-socket.io-%2B-mongodb","createDate":1462086345088,"id":"simple-chat-room-with-express-%2B-socket.io-%2B-mongodb","thumb":"https://images.unsplash.com/photo-1581656506224-6eae257ceb04?ixlib=rb-1.2.1&q=80&fm=jpg&crop=entropy&cs=tinysrgb&w=400&fit=max&ixid=eyJhcHBfaWQiOjEwNTE3MH0"},{"intro":"<p>Node.js是能够在服务器端运行JavaScript的开放源代码、跨平台JavaScript运行环境。它让JS脱离了浏览器的限制，在更多的平台上运行。近几年是越来越火。让它这么火的原因有哪些呢？</p>\n<ul>\n<li>基于C++的Chrome V8引擎让它速度非常快</li>\n<li>事件循环与异步I/0让它可以轻松处理高并发</li>\n<li>统一技术栈</li>\n<li>服务端渲染（同构Web应用）</li>\n<li>...</li>\n</ul>\n<p>本文主要就第二点谈谈，什么是事件循环与异步I/O，以及他们是怎样处理高并发的。</p>\n","content":"<p>Node.js是能够在服务器端运行JavaScript的开放源代码、跨平台JavaScript运行环境。它让JS脱离了浏览器的限制，在更多的平台上运行。近几年是越来越火。让它这么火的原因有哪些呢？</p>\n<ul>\n<li>基于C++的Chrome V8引擎让它速度非常快</li>\n<li>事件循环与异步I/0让它可以轻松处理高并发</li>\n<li>统一技术栈</li>\n<li>服务端渲染（同构Web应用）</li>\n<li>...</li>\n</ul>\n<p>本文主要就第二点谈谈，什么是事件循环与异步I/O，以及他们是怎样处理高并发的。</p>\n<h2 id=\"什么是异步\">什么是异步</h2>\n<p>计算机领域中的同步和异步的概念和我们平时生活中的同步和异步是不一样的：</p>\n<pre><code>同步就是整个处理过程顺序执行，当各个过程都执行完毕，并返回结果。是一种线性执行的方式，执行的流程不能跨越。\n\n异步则是只是发送了调用的指令，调用者无需等待被调用的方法完全执行完毕；而是继续执行下面的流程。是一种并行处理的方式，不必等待一个程序执行完，可以执行其它的任务</code></pre><p>我们经常听到的Ajax请求的A就是异步(Asynchronous)的意思。浏览器中JavaScript在单线程上执行，而且与UI渲染共用一个线程。这意味着在js执行的时候，UI渲染和响应是处于停滞状态的。这就是为什么我们用js进行大量计算时页面会卡主。</p>\n<p>如果前端发请求是通过同步的方式，那么js需要等到后端返回数据后才能继续执行。这期间UI将停顿，无法响应用户的交互行为。但是通过发送异步请求，js和UI渲染可以继续执行，等收到响应的数据执行回调即可。用户体验更佳。</p>\n<h2 id=\"什么是io\">什么是I/O</h2>\n<p>I/O在计算机中指Input/Output，也就是输入和输出。比如磁盘I/O，网络I/O等进行数据交换的操作。</p>\n<h3 id=\"什么是异步io\">什么是异步I/O</h3>\n<p>计算机在发展过程中将组件进行了抽象，分为I/O设备和计算设备。通常CPU与I/O是可以并行的。假如有一下代码：</p>\n<pre><code><span class=\"hljs-keyword\">var</span> result = <span class=\"hljs-keyword\">db</span>.<span class=\"hljs-keyword\">query</span>(<span class=\"hljs-string\">\"select * from T\"</span>);\n<span class=\"hljs-comment\">// use result</span></code></pre><p>思考一下执行这行SQL的时候，其实是调用了I/O操作，那么在数据返回之前，CPU在干嘛？是不是空闲了。</p>\n<p>假如处理一个请求需要来自查询两份数据，第一个耗时M，第二个耗时N，采用同步的方式，代码如下：</p>\n<pre><code><span class=\"hljs-comment\">// 消费时间为M</span>\n<span class=\"hljs-selector-tag\">getData</span>(<span class=\"hljs-string\">'from_db'</span>);\n<span class=\"hljs-comment\">// 消费时间为N</span>\n<span class=\"hljs-selector-tag\">getData</span>(<span class=\"hljs-string\">'from_remote_api'</span>);</code></pre><p>第一个资源获取后才会获取第二个资源，总耗时 M+N。但是如果采用异步的方式：</p>\n<pre><code>getData(<span class=\"hljs-string\">'from_db'</span>, <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-params\">(result)</span> </span>{\n<span class=\"hljs-comment\">// 消费时间为M</span>\n});\n\ngetData(<span class=\"hljs-string\">'from_remote_api'</span>, <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-params\">(result)</span> </span>{\n<span class=\"hljs-comment\">// 消费时间为N</span>\n});</code></pre><p>第一个资源并不会阻塞第二个资源的获取，总耗时max(M, N)。随着应用越来越复杂，同步和异步的优劣会越来越明显。</p>\n<p>I/O是昂贵的，<strong>异步I/O能更快的响应资源</strong>。</p>\n<p><img src=\"http://tech.yuceyi.com/upload/28b0c513315b4c13a96a46f7ac7bac6b_image.png\" alt=\"28b0c513315b4c13a96a46f7ac7bac6b_image.png\"></p>\n<p>官方有个小例子也体现了异步的高效：<a href=\"https://nodejs.org/en/docs/guides/simple-profiling/\">https://nodejs.org/en/docs/guides/simple-profiling/</a></p>\n<p>在登录注册的逻辑中，我们经常会用到加密算法，这种复杂计算是很耗CPU的。上面的文章提到使用同步代码进行加密计算时，每秒处理的请求数是5，而改成了异步代码进行加密计算时，每秒处理的请求数变成四舍五入就是20，提升了4倍的性能。</p>\n<h2 id=\"异步io的实现\">异步I/O的实现</h2>\n<p>异步I/O并非Node原创。下面我们看一下操作系统对异步I/O的支持情况。</p>\n<h3 id=\"阻塞与非阻塞\">阻塞与非阻塞</h3>\n<p>在讨论同步/异步时，我们也尝尝听到阻塞和非阻塞，从效果上讲异步和非阻塞好像是一回事。但是对于计算机内核来说，它们是两回事。操作系统内核对于I/O只有两种方式：阻塞与非阻塞。</p>\n<p>阻塞I/O是调用之后一定要等到数据返回，这个调用才结束。</p>\n<p><img src=\"http://tech.yuceyi.com/upload/4d19e938b5644a81924735fca57a4723_image.png\" alt=\"4d19e938b5644a81924735fca57a4723_image.png\"></p>\n<p>阻塞I/O造成CPU等待I/O, 浪费等待时间，CPU的处理能力不能得到充分利用。为了提高性能，内核提供了非阻塞I/O。</p>\n<p><img src=\"http://tech.yuceyi.com/upload/803ca124254e42198715f684acc85f1e_image.png\" alt=\"803ca124254e42198715f684acc85f1e_image.png\"></p>\n<p>操作系统对计算机进行了抽象，将所有输入输出设备抽象为文件。内核在进行文件I/O操作时，通过文件描述符(fd)进行管理。进行I/O调用时，先打开文件描述符，再根据文件描述符去实现文件的数据读写。</p>\n<p>非阻塞I/O在调用后不带数据立即返回，CPU可以继续处理其他事务，提升了性能。但带来的问题是，我们并不知道I/O是否完成。为了获取完整的数据，程序需要重复调用I/O来确认，即<strong>轮询</strong>。</p>\n<p>现有的轮询技术主要有：read, select, poll和epoll。</p>\n<p>read是最原始，性能最低的一种，通过重复调用来检查I/O状态获取完整的数据。在得到数据前，CPU一直耗在等待上。</p>\n<p><img src=\"http://tech.yuceyi.com/upload/30ebef2fb9304bf2b07bf3680ab9e7b0_image.png\" alt=\"30ebef2fb9304bf2b07bf3680ab9e7b0_image.png\"></p>\n<p>select在read基础上进行了改进，可以同时监听多个文件描述符，进行非阻塞调用后，通过不断遍历每个文件描述符上的事件状态来判断I/O是否完成，属于多路复用I/O的一种。它的限制是状态存储在一个1024长度的数组中，所以最多同时检查1024个文件描述符。</p>\n<p><img src=\"http://tech.yuceyi.com/upload/e4f98fc94dc6422b944cd208e5c6c94f_image.png\" alt=\"e4f98fc94dc6422b944cd208e5c6c94f_image.png\"></p>\n<p>poll跟sellect类似，进行了一些改进，采用链表的方式突破数组的长度限制。但是poll和select都需要遍历，当文件描述符比较多的时候，性能比较低。</p>\n<p>epoll是Linux下效率最高的I/O事件通知机制，如果没有检查到I/O事件，会进行休眠，直到事件将它唤醒。利用了事件通知，执行回调的方式，而不是遍历查询，不会浪费CPU，执行效率高。但是如果I/O事件并不多的情况下，epoll并非性能最高的，毕竟实现事件通知机制也会有一定消耗。</p>\n<p><img src=\"http://tech.yuceyi.com/upload/eac966fd47684d69a005ff291ee1fb9f_image.png\" alt=\"eac966fd47684d69a005ff291ee1fb9f_image.png\"></p>\n<p>如果要形象的描述一下这几个轮询，可以理解为公司有好几个需求(I/O事件)需要开发，每个需求分配了一个产品(线程)，每个需求交给一个开发去完成(进行I/O调用)，每个产品需要不断的去问对应的开发需求(I/O调用)是否完成，这就是read。</p>\n<p>后来公司引入了jira统一管理需求，把这几个需求在jira上都交给一个产品(线程)去管理，每个需求还是交给一个开发去完成(进行I/O调用)，但只需要这个产品去不断查看每个jira的状态即可(遍历)，这种就是select和poll的方式。</p>\n<p>再后来公司又启用了企业微信，开发开发完后直接在企业微信上通知(事件通知)产品开发完了，不用产品一个一个去查看状态了，这种就是epoll的方式。</p>\n<h3 id=\"异步io的理想与现实\">异步I/O的理想与现实</h3>\n<p>我们期望的异步I/O是应用程序发起I/O调用后，无须通过遍历或者事件通知等方式轮询，可以直接处理后续逻辑，只需要在I/O完成后将数据返回给应用程序执行回调。</p>\n<p><img src=\"http://tech.yuceyi.com/upload/3b9cb346c07149638576a41fabff06f6_image.png\" alt=\"3b9cb346c07149638576a41fabff06f6_image.png\"></p>\n<p>而现实中的异步I/O大多是通过线程池的方式来间接实现的。让部分线程进行阻塞I/O或者非阻塞I/O加轮询技术来完成数据获取，让一个线程进行计算处理，通过线程之间的通信进行数据传递，可以轻松实现异步I/O。</p>\n<p><img src=\"http://tech.yuceyi.com/upload/8f524f1ae111459f99a01b58674b6bd9_image.png\" alt=\"8f524f1ae111459f99a01b58674b6bd9_image.png\"></p>\n<h3 id=\"跨平台的异步io实现\">跨平台的异步I/O实现</h3>\n<p>Node是跨平台的，上面我们说的就是Unix系统，在Windows平台上，本身提供了一个理想的异步I/O——IOCP，虽然它内部仍然是线程池的原理，只不过这些线程池是有系统内核管理的而非应用程序。Node提供了libuv作为抽象封装层，兼容了不同平台间的差异。</p>\n<p><img src=\"http://tech.yuceyi.com/upload/de7a832ab9af4b6dad29b499873f0efb_image.png\" alt=\"de7a832ab9af4b6dad29b499873f0efb_image.png\"></p>\n<p>所以虽然我们常说Node是单线程的，其实只是说js执行在单线程中，内部完成I/O任务的另有线程池。</p>\n<h3 id=\"node的异步io\">Node的异步I/O</h3>\n<p>介绍完异步I/O的实现，还要说一下Node的执行模型，完成整个异步I/O的有事件循环，观察者和请求对象等。</p>\n<h4 id=\"事件循环\">事件循环</h4>\n<p>在进程启动时，Node便会创建一个类似于while(true)的循环，每执行一次循环体的过程我们称为Tick。每个Tick的过程就是查看是否有事件待处理，如果有，就取出事件及其相关的回调函数。如果存在关联的回调函数，就执行它们。然后进入下个循环，如果不再有事件处理，就退出进程。</p>\n<p><img src=\"http://tech.yuceyi.com/upload/bdecb4903b1e4bd9b892a1e82a0644b4_image.png\" alt=\"bdecb4903b1e4bd9b892a1e82a0644b4_image.png\"></p>\n<h4 id=\"观察者\">观察者</h4>\n<p>在每个Tick的过程中，如何判断是否有事件需要处理呢？这里就要引入观察者的概念，每个事件循环中有一个或多个观察者，而判断是否有事件要处理就是向这些观察者询问。</p>\n<p>在浏览器中，事件可以能来自用户交互行为，比如点击一个按钮等等，都有对应的观察者。在Node中，事件可能来自网络请求，文件I/O等，这些事件对应的观察者有文件I/O观察者，网络I/O观察者等。</p>\n<p>事件循环是一个典型的生产者/消费者模型。异步I/O、网络请求等则是事件的生产者，源源不断为Node提供不同类型的事件，这些事件被传递到对应的观察者那里，事件循环则从观察者那里取出事件并处理。</p>\n<h4 id=\"请求对象\">请求对象</h4>\n<p>异步I/O的回调函数不是由我们开发者调用的。从js发起调用到内核执行完I/O操作的过渡过程中，存在一种中间产物，叫做请求对象。</p>\n<p>以<code>fs.open()</code>为例，从js调用Node的核心模块(fs)，核心模块调用C++内建模块，内建模块通过libuv进行系统调用。libuv进行系统调用过程中，创建了一个请求对象，从js层传入的参数和当前方法都被封装在这个请求对象中，回调函数也设置在这个对象的oncomplete_sym属性上。对象包装完毕后，就被推入线程池中等待执行。</p>\n<p>至此，js调用立即返回，由JavaScript层面发起的异步调用的第一阶段就此结束。 JavaScript线程可以继续执行当前任务的后续操作。当前的I/O操作在线程池中等待执行，不管它是否阻塞I/O，都不会影响到JavaScript线程的后续执行，如此就达到了异步的目的。</p>\n<p>请求对象是异步I/O过程中的重要中间产物，所有的状态都保存在这个对象中，包括送入线程池等待执行以及I/O操作完毕后的回调处理。</p>\n<h4 id=\"执行回调\">执行回调</h4>\n<p>组装好请求对象、送入I/O线程池等待执行，实际上完成了异步I/O的第一部分，回调通知是第二部分。</p>\n<p>在事件循环的每次Tick过程中，也存在I/O观察者去检查线程池中是否有执行完的请求，如果存在，会将请求对象加到I/O观察者的队列中，然后将其当做事件处理。</p>\n<p>I/O观察者回调函数的行为就是取出请求对象的result属性作为参数，取出oncomplete_sym属性作为方法，然后调用执行，以此达到调用JavaScript中传入的回调函数的目的。</p>\n<p>以Windows平台上的IOCP为例，整个异步I/O的流程大概是：</p>\n<p><img src=\"http://tech.yuceyi.com/upload/61ad2742e89c4c249712ce65c4e387ae_image.png\" alt=\"61ad2742e89c4c249712ce65c4e387ae_image.png\"></p>\n<p>事件循环、观察者、请求对象、I/O线程池这四者共同构成了Node异步I/O模型的基本要素。</p>\n<h2 id=\"事件驱动\">事件驱动</h2>\n<p>事件驱动是在持续的事物管理过程中，由当前时间节点上出现的事件引起的调用可用资源执行相关任务，解决问题，防止事物堆积的一种策略。前面介绍异步的实现原理也基本勾勒处理事件驱动的实质，即通过主循环加事件触发的方式来运行程序。基于Node构建的Web服务器也是通过事件驱动来处理请求的。</p>\n<p><img src=\"http://tech.yuceyi.com/upload/9142627df5b34afcbc6450c11f0ea42a_image.png\" alt=\"9142627df5b34afcbc6450c11f0ea42a_image.png\"></p>\n<p>下面为几种经典的服务器模型</p>\n<ul>\n<li>同步式。对于同步式的服务，一次只能处理一个请求，并且其余请求都处于等待状态。</li>\n<li>每进程/每请求。为每个请求启动一个进程，这样可以处理多个请求，但是它不具备扩展性，因为系统资源只有那么多。</li>\n<li>每线程/每请求。为每个请求启动一个线程来处理。尽管线程比进程要轻量，但是由于每个线程都占用一定内存，当大并发请求到来时，内存将会很快用光，导致服务器缓慢。</li>\n</ul>\n<p>多线程优点是可以高效利用多核CPU，缺点是创建线程需要消耗内存，CPU在线程之间进行上下文切换需要花费时间，还有最头痛的状态同步问题等等。Apache采用的是每线程/每请求的方式，而Nginx则是事件驱动，我们看一下这两个的性能比较：</p>\n<p><img src=\"http://tech.yuceyi.com/upload/67bbbba6a2d34116a2bee74664c9d606_image.png\" alt=\"67bbbba6a2d34116a2bee74664c9d606_image.png\">\n<img src=\"http://tech.yuceyi.com/upload/34e201b99a0f4197b9b66fd53af3886c_image.png\" alt=\"34e201b99a0f4197b9b66fd53af3886c_image.png\"></p>\n<p>我们可以看到，随着并发数的增加，nginx每秒处理的请求数更多(省去了多线程上下文切换的消耗)，占用的内存基本不变，apache内存线性增加(每个线程占用一定的内存)。所以事件驱动在处理高并发时性能是非常高的。</p>\n<p>参考链接：\n《深入浅出Node.js》\n<a href=\"https://blog.csdn.net/shiyong1949/article/details/80854656\">https://blog.csdn.net/shiyong1949/article/details/80854656</a>\n<a href=\"https://nodejs.org/en/docs/guides/simple-profiling/\">https://nodejs.org/en/docs/guides/simple-profiling/</a>\n<a href=\"https://www.zhihu.com/question/28594409\">https://www.zhihu.com/question/28594409</a>\n<a href=\"http://s3.amazonaws.com/four.livejournal/20091117/jsconf.pdf\">http://s3.amazonaws.com/four.livejournal/20091117/jsconf.pdf</a></p>\n","title":"深入浅出Node.js之事件循环与异步I/O","tags":["Node.js"],"slug":"in-depth-explanation-of-the-event-loop-and-asynchronous-i%2Fo-of-node.js","createDate":1575367200000,"id":"in-depth-explanation-of-the-event-loop-and-asynchronous-i%2Fo-of-node.js","thumb":"https://images.unsplash.com/photo-1580309237429-661ea7cd1d53?ixlib=rb-1.2.1&q=80&fm=jpg&crop=entropy&cs=tinysrgb&w=400&fit=max&ixid=eyJhcHBfaWQiOjEwNTE3MH0"}]